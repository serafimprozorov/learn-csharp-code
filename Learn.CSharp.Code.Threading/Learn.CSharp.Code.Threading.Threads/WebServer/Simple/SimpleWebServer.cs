using Learn.CSharp.Code.Threading.WebServer;

namespace Learn.CSharp.Code.Threading.Threads.Simple
{
    using System;
    using System.Net;
    using System.Threading;
    using System.Collections.Generic;
    using System.Linq;
    
    using WebServer;
    
    using static System.Threading.ThreadState;
    
        
    /// <summary>
    /// Реализация в общем-то похожа на предыдущую, но во-первых использует потоки из пула, а во-вторых
    /// использует очередь соединений.
    /// </summary>
    public class SimpleWebServer : IWebServer
    {
        private readonly WebServerOptions _options;
        private readonly Thread _thread;
        private readonly HttpListener _listener;
        
        /// <summary>
        /// Очередь соединений, ниже поясню ее назначение. 
        /// В те страшные времена про ConcurrentQueue никто не слышал.
        /// </summary>
        private readonly Queue<HttpListenerContext> _clientQueue = new Queue<HttpListenerContext>();
 
        /// <summary>
        /// См. ILock и его реализации.
        /// Здесь мы будем использовать спинлок, потому как мало вероятности, 
        /// что очередь будет заблокирована надолго.
        /// </summary>
        private readonly ILock _lock = new SpinLockWrapper();

        
        private bool _disposed;

        
        
        public SimpleWebServer(WebServerOptions options)
        {
            _options = options ?? throw new ArgumentNullException(nameof(options));
            _listener = new HttpListener();
            _listener = new HttpListener();
            _thread = new Thread(Listen);
            
            _listener.Prefixes.Add($"http://{_options.Host}:{_options.Port}/");
        }

        
        public void Start()
        {
            /*
             *   Есть два способа выполнить код в другом потоке (на самом деле -- 3, но третий -- частность второго):
             *
             *  - Создать поток с помощью класса Thread и запустить его;
             *  - Поставить задачу в очередь с помощью класса ThreadPool
             *
             * 
             *   В первом случае создается новый поток, для него выделяются ресурсы;
             *
             *   Во втором все несколько интереснее. Потоки в пуле постоянно готовы к запуску, вернее даже не так,
             * они постоянно запущены, но ждут появления новой задачи, пример реализации пула потоков можно посмотреть
             * здесь: https://github.com/serafimprozorov/interview-tvema-test, можно еще в исходниках .NET, но по ссылке
             * она банально проще. Таким образом создание потоков из пула -- менее затратная операция, кроме того,
             * в пуле также существуют т.н. потоки ввода-вывода, это -- черная магия и про нее я расскажу в следующем
             * примере.
             *
             *   Напомню, что остановленный поток нельзя запустить заново, то есть, очевидно, что не стоит
             * останавливать потоки из пула, также надо помнить, что потоки в пуле ограничены и не стоит брать их оттуда
             * бесконтрольно. В примере я использую класс Thread для создания потока прослушивания и ThreadPool для
             * потоков обработки соединений.
             *
             */
            
            
             // Запускаем потоки, которые будут обрабатывать соединения.
             // В принципе, мы создаем тот самый FixedThreadPool из премера с гитхаба, только проще.
             if (!Enumerable.Range(0, _options.Concurrency).Any(i => ThreadPool.QueueUserWorkItem(ListenQueue)))
                throw new Exception("Unabled to start handlers");
            
             //Запускаем поток обработки соединений
            _thread.Start();
        }


        public void Stop(int timeoutMs) => _listener.Stop();


        public void Dispose()
        {
            if (_disposed) return;
            
            _disposed = true;
            
            // Мы проверяем, что поток уже не остановлен, второй раз остановить его нельзя, как и запустить
            if (_thread.ThreadState != Stopped && _thread.ThreadState != Aborted)
            {
                 /*
                  *   И останавливаем его принудительно с эксепшном.
                  * Есть два варианта остановить поток: с использованием while(flag) и с использованием
                  * ThreadAbortException, его бросает в целевом потоке метод Abort(),
                  * Поскольку, у нас предусмотрен метод Stop, то мы предполагаем, что что-то пошло не так
                  * и сервер не остановился, все может быть, поэтому, здесь мы должны остановить поток.
                  * То есть, даже, если у нас есть флаг, то обрабатывать вышеназванное исключение надо, да,
                  * в первом примере мы этого не делали, но он и никуда не годится.
                 */
                _thread.Abort();
            }
        }


        private void Listen()
        {
            _listener.Start();

            try
            {
                // Крутимся, пока слушатель активен
                while (_listener.IsListening)
                {
                    // Оборачиваем в try, чтобы одним неудачным соединенем не убить приложение, мы же не node.js
                    try
                    {
                        // Ждем соединения, поток заблокирован
                        var context = _listener.GetContext();
                        
                        /*
                         *   В этот момент слушатель снова может принимать соединения,
                         * Но ему мешает код ниже, следовательно код ниже должен выполняться,
                         * как можно, быстрее.
                         *
                         *   Мы используем очередь подключений.
                         * Будем просто добавлять поделючение в очередь, а потоки обработки будут
                         * забирать их оттуда. У нас один писатель, однако, считается, что методы типа queue
                         * непотокбезопасны, это может быть, например потому, что в процессе добавления перевыделяется
                         * память и перемещаются данные, напомню, что массив нельзя увеличить или уменьшить на месте,
                         * можно только перевыделить, Array.Resize делает именно это.
                         *
                         *   Здесь будем ждать до посинения, потому что непонятно, что иначе делать с запросом. 
                         */
                        using (var lc = _lock.Acquire())
                        {
                            _clientQueue.Enqueue(context);
                        }
                    }
                    catch (Exception)
                    {
                        // Здесь предполагается логирование.
                    }
                }
            }
            catch (ThreadAbortException)
            {
                // Здесь не делаем ничего и это, представь себе, в нашем случае -- норм, хотя,
                // в реальном приложении мы захотим добавить сюда сообщение о том, что что-то пошло не совсем так и
                // и сервер не остановился нормально.
            }
            
            // Закрываем соединения.
            _listener.Close();
        }

        private void ListenQueue(object queue)
        {
            while (_listener.IsListening)
            {
                using (var lc = _lock.Acquire(_options.QueueWaitingTimeoutMs))
                {
                    if (!lc.IsTaken || _clientQueue.Count == 0)
                    {
                        /*
                         *   Есть вероятность, что, например у нас пустая очередь, а при этом поток, который пишет
                         * в очередь не может получить блокировку, при этом, наш поток (читатель) еще не отработал свой
                         * квант времени и не отдает управление (то есть после того, как блокировка не получена,
                         * продолжается выполнение и запустится следующая итерация while), выходит такой микродедлок,
                         * он длится очень мало, но факт неприятен. Этой инструкцией мы подсказываем планировщику
                         * потоков отдать квант времени другому потоку.
                         */
                        Thread.Yield();
                        continue;
                    }

                    var context = _clientQueue.Dequeue();

                    // Выходим из блокировки, нам больше не нужна очередь
                    lc.Release();
                    
                    using (context.Response.OutputStream)
                    {
                        HandleConnection(context.Request, context.Response);
                    }
                }
            }
        }
        
        private void HandleConnection(HttpListenerRequest req, HttpListenerResponse res)
        {
            try
            {
                if (_options.Handlers.Any(h => h.HandleRequest(req, res))) return;
                res.NotFound();
            }
            catch (Exception)
            {
                // Логирование тут, наверное
                res.IntenalServerError();
            }
        }
    }
}

/*
 *   В этом примере показан многопоточный сервер и спинлоки;
 *
 * Хорошо: сервер многопоточный, однако, не плодит потоки бесконечно, нет необходимости ожидать завершения
 *                   соединений при остановке (их потоки остановятся сами, вернее, вернутся в пул)
 * 
 * Плохо: Не используются потоки ввода-вывода из пула, их продемонмтрирую в следующем примере. для чего они нужны:
 *        в нашем случае осуществляется очень много операций ввода-вывода, они по природе своей -- блокирующие, то есть,
 *        текущий поток блокируется и ждет, пока закончится операция ввода-вывода. В случае потоков из пула это -- вообще
 *        очень плохо, ибо они могут так закончиться.
 *
 *   Кроме обычных потоков пул CLR содержит потоки для ввода-вывода, они используются при вызове методов
 * BeginXXX()/EndXXX(). При этом работает IOCP, событийная модель ввода-вывода, как в nginx или node
 * (впрочем в них и рабоает именно она, если мы под виндой, под Линуксом это зовется epoll), то есть, пока поток,
 * который вызвал метод ввода не нужен, он вернется в пул и будет дальше обрабатывать запросы, когда понадобится
 * продолжить исполнение кода, оно продолжится в другом (а может быть и том же) потоке из пула. Мы не будем
 * рассматривать методы BeginXXX/EndXXX, т.к. механизм признан устаревшим еще в далеком 2010 году после выхода .NET 4.0
 * и появления тасков, то есть, следующий шаг -- таски без async/await.
 */
